import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const screensDir = path.join(__dirname, "src", "screens");
const outputFile = path.join(__dirname, "src", "componentMapping.ts");

function walkDir(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat.isDirectory()) {
      walkDir(filePath, fileList);
    } else if (file.endsWith(".svelte")) {
      const relativePath = path
        .relative(screensDir, filePath)
        .replace(/\\/g, "/")
        .replace(/\.svelte$/, "");
      fileList.push(relativePath);
    }
  });
  return fileList;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function processArray(arr) {
  // Define the values to check for removal
  const valuesToRemove = ["_", "index", "_index", "__index"];

  // Check if the last element matches any of the values to remove
  if (valuesToRemove.includes(arr[arr.length - 1])) {
    arr.pop(); // Remove the last element
  }

  // Replace elements starting with [ or *
  const processedArr = arr.map((element) => {
    if (element.startsWith("[") || element.startsWith("*")) {
      return ":" + element.replace("[", "").replace("]", "").replace("**", "");
    }
    return element;
  });

  return processedArr;
}
function arrayToNestedObject(arr) {
  let nestedObject = {};
  let currentLevel = nestedObject;

  for (let i = 0; i < arr.length; i++) {
    let key = arr[i];
    currentLevel[key] = {};
    currentLevel = currentLevel[key];
  }

  // The last key should have an empty string as its value
  let lastKey = arr[arr.length - 1];
  currentLevel[lastKey] = "";

  return nestedObject[arr[0]];
}

const components = walkDir(screensDir);
let routesArray = components.map((component) =>
  processArray(component.split("/"))
);
let theRouteNames = [];
let routeText = routesArray
  .map((route) => {
    let fullPath = route.join("/").replaceAll("+", "");
    let varName =
      "_" +
      route
        .map((it) => capitalize(it.replaceAll(":", "").replaceAll("+", "")))
        .join("");

    theRouteNames.push(varName);
    let parsers = route
      .map((segment) => {
        let segmentName = segment.replace(":", "");
        let parserType = "stringParser";
        if (segmentName.includes("+")) {
          segmentName = segmentName.replace("+", "");
          parserType = "intParser";
        }

        if (segment.startsWith(":")) {
          return `"${segmentName}": ${parserType}`;
        }
      })
      .filter((it) => it != null)
      .join(",\n");

    return `
   const ${varName} = route("${fullPath}", { 
    ${parsers}
    }, {});
  `;
  })
  .join("");

let RoutesExport = theRouteNames.reduce((prev, curr, index) => {
  if (index == theRouteNames.length - 1) {
    return prev + "    " + curr + "\n}";
  } else {
    return prev + "    " + curr + ",\n";
  }
}, "export const R ={\n");

let keyValue = components
  .map((component) => {
    let initial = `'${component}': () => import('./screens/${component}.svelte')`;
    if (component == "index") {
      initial += `,\n'': () => import('./screens/${component}.svelte'),`;
      initial += `\n'/': () => import('./screens/${component}.svelte')`;
    }
    return initial;
  })
  .join(",\n");

const mappingContent = `
import additionalRoutes from "./additionalRoutes.js";
import { route,stringParser ,intParser  } from "typesafe-routes";

${routeText}

${RoutesExport}

 let routeObject = ${JSON.stringify(routesArray)}

  // generated by generate-tree.js
export const componentMapping = {
${keyValue},
...additionalRoutes
};


  export type Route = ${components
    .map((component) =>
      JSON.stringify(processArray(component.split("/")).join("/"), undefined, 2)
    )
    .reduce((acc, curr) => {
      return acc + "|" + curr;
    }, "")

    .slice(1)};

type ExcludeWildcard<T> = T extends \`\${infer _Start}*\${infer _End}\` ? never : T;

type ValidRoute<T> = ExcludeWildcard<T> extends string ? T : never;

export type SafeRoute = ValidRoute<Route>;
export type _Route = {
    $: string;
} & {}






`;

fs.writeFileSync(outputFile, mappingContent.trim());

console.log(`Component mapping generated at ${outputFile} `);
